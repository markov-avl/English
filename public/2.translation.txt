ЗНАЧЕНИЕ ПАРАЛЛЕЛЬНОГО ПРОГРАММИРОВАНИЯ

Схему 1 на самом деле можно считать бессмысленной, потому что нет необходимости рисовать схему потоков в таких простых случаях с такой детальностью. Разветвление и повторное объединение потоков происходит автоматически, и программисту не нужно об этом беспокоиться. Также одна из ветвей очень проста, требуя только элементарного управляющего устройства для выполнения.

Может возникнуть вопрос, возникает ли ситуация, когда обе параллельные ветви программы достаточно сложны, чтобы оправдать использование программирования с помощью серии инструкций, а не одной начальной инструкции. Ответ на этот вопрос однозначно да. В таких ситуациях имеются две параллельные активности, каждая из которых определена программой инструкций, этот тип программирования называется Параллельным Программированием.

Параллельное Программирование будет использоваться как в Sperry Rand LARC (Экер, 1956), так и в IBM Stretch (Данвелл, 1956). Обе эти машины будут содержать специальные компьютеры для обработки ввода и вывода информации, которые будут программироваться с помощью серии инструкций. Кроме того, в LARC предусмотрена возможность совместной работы двух основных компьютеров.

Необходимо отметить, что эта ситуация сильно отличается от наличия двух полностью отдельных компьютеров, стоящих рядом. Компьютеры внутри LARC или Stretch имеют доступ к одному и тому же хранилищу и могут участвовать в одном и том же вычислении. Следовательно, требуется наличие управляющих связей, чтобы один компьютер не опережал другой. Все это породит увлекательные проблемы в программировании. Эти проблемы можно разделить на три типа:
1) проблемы создания блок-схем;
2) программирование управляющих связей, предотвращающих опережение одного компьютера другим;
3) распределение памяти для различных частей программы и наборов данных.

На данный момент очень мало работы было выполнено по этим проблемам. Цель данной статьи - лишь определить область, требующую исследования, и указать на некоторые возможные последствия применения техники параллельного программирования.

РАЗДЕЛЕНИЕ ВРЕМЕНИ

До сих пор тема параллельного программирования вводилась только в ситуациях, когда имеются две или более отдельные части машины, каждая из которых обрабатывает свою ветвь программы. Однако аналогичные логические проблемы программирования могут возникнуть и в ситуации, когда имеется только один управляющий блок. Это происходит, когда один управляющий блок делит свое время между двумя различными задачами. Строго говоря, управляющий блок не выполняет две разные части программы одновременно, но если он часто переключается с одной части на другую, общий эффект будет аналогичен выполнению двух частей одновременно. Фигура 2 показывает в грубой форме, как может происходить управление.

На первый взгляд нет смысла вводить разделение времени, поскольку если две части программы выполняются одна за другой на полной скорости, это не займет больше времени, чем выполнение их в любом другом порядке. Однако на практике может быть очень реальное преимущество в разделении времени. Это происходит потому, что одна из ветвей может время от времени останавливаться, ожидая готовности периферийного устройства для работы. В обычном программировании компьютер должен оставаться неактивным в этот период, но при использовании разделения времени можно организовать, чтобы управляющий блок перешел к другой ветви программы, которая не задерживается таким образом.

Разделение времени не является совершенно новой идеей. Многие люди писали программы, используя обычные методы программирования, в которых время, которое компьютер мог бы провести в ожидании работы периферийного устройства, использовалось для выполнения другой части программы. Однако написание таких программ не является простым. Необходимо примерно оценить, сколько времени потребуется для каждой операции, и как-то организовать программу так, чтобы в эти периоды выполнялось приблизительно необходимое количество работы. Тайминг циклов и тд в вычислениях может сделать такое программирование чрезвычайно трудным.

Разделение времени может быть полезно, например, при управлении позиционированием магнитной ленты. Считается, что магнитная лента должна быть способна позиционироваться на любой блок, чей адрес задан случайным образом. В общем, этот процесс позиционирования может занять несколько секунд, поэтому желательно, чтобы обычное вычисление продолжалось одновременно, если это возможно. Однако процесс позиционирования довольно сложен, так как включает определение соответствующего направления движения, вычисление количества блоков, которые нужно пройти, подсчет этих блоков по мере их прохождения и, вероятно, проверку адресов блоков по пути. Следовательно, любое специальное управляющее устройство, построенное для выполнения этой задачи, должно быть достаточно сложным. Однако позиционирование магнитной ленты не является постоянной задачей для вычислительного устройства. Необходимая арифметика может быть выполнена электронно за лишь малую часть времени, фактически требуемого для позиционирования. Поэтому, если компьютер сможет делить свое время между позиционированием ленты и выполнением вычислений, последние могут выполняться почти с нормальной скоростью.

Эта идея была использована с EDSAC I в Кембриджском университете в Математической лаборатории (Уилкс и Уиллис, 1956). Специальные подпрограммы были написаны для подсчета блоков на ленте и управления ее движением. Одна из этих подпрограмм включалась в каждую программу, использующую магнитное ленточное оборудование. Каждый раз, когда блок проходил мимо считывающей головки, специальный маркер блока вызывал установку триггера внутри машины. Каждый раз при этом управление передавалось подпрограмме позиционирования. После того как подпрограмма учитывала блок и выполняла все необходимые действия, она возвращала управление основной программе.

В этом случае программисту не нужно было проектировать свою программу так, чтобы она вписывалась в промежутки между операциями подсчета блоков. Машина работала на полной скорости, переключаясь на подпрограмму позиционирования только по необходимости; программист не мог заранее предсказать точные моменты, в которые его программа будет прерываться подпрограммой позиционирования. Средства, использованные для этого, были достаточно стандартными. Была предусмотрена условная инструкция перехода, действие которой зависело от состояния триггера, регистрирующего прохождение маркеров блоков. Эта инструкция использовалась таким образом, чтобы первый раз, когда она встречалась после прохождения блока, управление передавалось подпрограмме позиционирования. Программисту требовалось разбрасывать копии этой инструкции по всей программе так, чтобы интервал времени между любыми двумя последовательными встречами с ними был меньше времени, необходимого для прохождения одного блока через механизм ленты. Это было, мягко говоря, утомительное требование. Однако оно позволяло довольно эффективно использовать компьютер во время позиционирования ленты.

АВТОМАТИЧЕСКОЕ ПРЕРЫВАНИЕ

Не существует принципиальной трудности в проектировании машины так, чтобы выполнение инструкций могло автоматически прерываться в результате внешнего сигнала. При этом можно достичь эффективного разделения времени без использования громоздких трюков программирования. EDSAC 2 фактически будет прерывать себя, чтобы подсчитывать прохождение блоков магнитной ленты. Однако в будущем один компьютер в частности станет классическим примером широкомасштабного применения техники разделения времени. Это компьютер TX-2 (Папиан, 1957), который сейчас близок к завершению в Лаборатории Линкольна Массачусетского технологического института.

TX-2 будет иметь специальные возможности для разделения времени между до 33 ветвями программы, и ожидается, что на самом деле будет использоваться значительное число из них. В общем, каждая ветвь будет обрабатывать одно периферийное устройство. Разделение времени будет выполняться на основе приоритетов: ветви, работающие с самыми быстрыми устройствами (например, магнитной лентой), будут получать самый высокий приоритет, а более медленные устройства (например, перфоратор бумажной ленты) будут иметь более низкий приоритет. Самый низкий приоритет будет у основной вычислительной задачи. Она не содержит ссылок на периферийные устройства и может быть выполнена в любое удобное время. Сложные встроенные схемы будут постоянно искать ветвь с наивысшим приоритетом, требующую внимания в данный момент, и будут обеспечивать переключение управления с одной ветви на другую.

Например, предположим, что вычисление достигло точки, в которой результаты готовы для записи на магнитную ленту. Тогда начинается ветвь программы, обрабатывающая вывод на магнитную ленту, и поскольку она имеет высокий приоритет, она немедленно берет на себя управление машиной. Она готовит первый кусок информации и отправляет его на магнитную ленту, готовит второй кусок, и не может делать больше, потому что магнитное ленточное оборудование все еще занято первым куском информации. Управление переходит к основной программе, которая теперь начинает другую часть вычисления. Как только магнитная лента готова принять второй кусок информации, основная программа прерывается, и управление снова передается ветви магнитной ленты. Таким образом, пока магнитная лента работает, управление машиной будет переключаться между двумя ветвями программы.

Кроме того, пока все это происходит, машина может также перфорировать информацию на бумажной ленте. В этом случае будет три ветви программы, требующие внимания время от времени, и управление может прыгать от одной к другой, как показано на cхеме 3(а).

- параллельный
- достаточный
- принятие
- положение
- увлекательные проблемы
- распределить
- редко
- оставаться неактивным
- вырвать
- довольно сложный
- прерывать
- резкий поворот
- переключаться		


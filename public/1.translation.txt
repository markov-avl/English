I. ВВЕДЕНИЕ

Архитектуры обработки сетевых пакетов часто используют гетерогенные процессоры в качестве ускорителей для ускорения выполнения классических подзадач в этой области применения. Наша реализация компилирует приложения в байткод для обобщенной виртуальной машины обработки пакетов, а затем использует копии интерпретатора с микрокодом, работающие параллельно, для выполнения обычных арифметических и управляющих инструкций, а также запускает выполнение ускорителей по мере необходимости (Рисунок 1).

Сделать такую систему программируемой для клиентов требует не только поддержки компиляции и развертывания приложений, но и поддержки их отладки и анализа. Представление исключений времени выполнения, особенно тех, которые происходят на ускорителях (специализированных сопроцессорах), в терминах местоположений исходного кода пользователя может быть сложной задачей, поскольку гетерогенные архитектуры могут требовать множества преобразований для перевода кода приложения в различные бинарные файлы. (Мы используем определение исключения Рэндалла Хайда как "вынужденного, а не запрошенного" - если пользователь сам выбросил исключение, он знал бы, где он это сделал). Поэтому мы сопоставляем исключения, сгенерированные системой, с местоположениями исходного кода пользователя путем:
- Инструментирования компилятора и инструмента низкоуровневого байткода для сохранения метаданных преобразования
- Сообщения об исключениях через интерпретатор в терминах смещений байткода
- Создания программного инструмента для сопоставления смещений байткода с кодом на языке ассемблера и исходным кодом на высокоуровневом языке

В этой статье описывается процесс преобразования программ, рассматривается взаимосвязь форм для интерактивной отладки, а затем описывается сходная проблема, вызванная отчетами об исключениях ускорителя. Мы предлагаем решение, основанное в основном на сопоставлении всех четырех форм программы. Наконец, мы подводим итоги, обсуждаем связанные технологии и предлагаем выводы.

II. ПРЕОБРАЗОВАНИЯ ФОРМ ПРОГРАММЫ: ОТ ВЫСОКОУРОВНЕВОГО ИСХОДНОГО КОДА К БИНАРНЫМ ФАЙЛАМ

Как показано на Рисунке 2, наша цепочка инструментов выполняет серию преобразований формы входной программы по мере перехода от анализа высокоуровневого исходного кода к интерпретации оптимизированных (упакованных) байт-кодов в бинарной форме. Эти преобразования следующие:
- Компилятор переводит высокоуровневый исходный код на языке packetC в абстрактный вид ассемблерного кода.
- Двухпроходный ассемблер преобразует ассемблерный код в байт-коды, которые кодируют ассемблерные инструкции в набор упакованных полей.
- Компоновщик объединяет различные объектные модули программы, объединяя их байт-коды в одну линейную последовательность в файле ELF (Executable and Linkable Format).
- Инструмент оптимизации байт-кодов упаковывает определенные последовательности байт-кодов, чтобы получить компактную бинарную форму.

Несмотря на некоторые особенности байт-кодов, эта последовательность преобразований характерна для классической цепочки инструментов: мы начинаем с исходного кода на высокоуровневом языке, проходим через промежуточный объектный код и заканчиваем исполняемым (или интерпретируемым) низкоуровневым кодом.

Текст ниже и Рисунок 3 показывают, как мы сопоставляем одну форму программы другой. Отдельные инструкции на высокоуровневом языке могут соответствовать нескольким инструкциям на ассемблере. Таким образом, имея множество H, содержащее инструкции h1 … hn на высокоуровневом языке packetC, и множество A, содержащее инструкции a1 … an на нашем языке ассемблера, мы можем определить списки L1 … Ln, где каждый является списком элементов из A. Мы определяем списки элементов из A, а не множества, потому что инструкция из A может появляться более одного раза в данном списке, Li.

Таким образом, преобразование программы packetC состоит из перевода каждого элемента H, h, в список Li, который содержит один или несколько элементов из A или является пустым списком. Элемент h сопоставляется с пустым списком, если у него нет соответствующей последовательности ассемблерных инструкций (например, это директива компилятора).

На следующем шаге инструкции языка ассемблера переводятся в неупакованные байт-коды. Мы поддерживаем однозначное сопоставление между инструкциями языка ассемблера и неупакованными байт-кодами. Таким образом, для множества неупакованных байт-кодов U для каждого элемента a в A существует только один элемент ui в U, такой что a переводится в (сопоставляется с) u1.

Наконец, программа, представленная в виде неупакованных байт-кодов (определенных элементами множества U, u1 … un), преобразуется в упакованные байт-коды (определенные элементами p1 … pn множества P).

Каждый элемент u сопоставляется с одним соответствующим элементом p1 в P. Некоторые неупакованные байт-коды представлены с использованием всего трех 32-битных слов, хотя в некоторых случаях используется до восьми слов. Упакованные байт-коды упаковывают поля инструкций в слова и байты как можно плотнее, чтобы ускорить работу интерпретаторов в режиме реального времени, минимизируя объем памяти инструкций, которую им нужно считывать.

Следующий раздел представляет знакомую проблему, требующую возможности сопоставления местоположений из одной из этих форм программы в местоположения в другой форме.

III. ПРИМЕР ВЫСОКОУРОВНЕВЫХ ФОРМ ДО НИЗКОУРОВНЕВЫХ: ИНТЕРАКТИВНАЯ ОТЛАДКА

Мы можем сохранять данные о том, как выполнялись сопоставления в "прямом" направлении (от высокоуровневых форм к низкоуровневым) для любого данного преобразования. Эти данные актуальны для создания интерактивных отладчиков для программ, написанных на высокоуровневых языках.

Напомним, что отдельные инструкции на высокоуровневом языке (HLL) часто сопоставляются с последовательностью нескольких инструкций на языке ассемблера. Интерактивный отладчик для HLL должен позволять пользователю установить точку останова (место, где выполнение прерывается) на данной инструкции HLL или строке исходного кода (Рисунок 4). Аналогично, команда шаг отладчика должна перемещать выполнение к точке непосредственно перед следующей инструкцией HLL.

Как показано на Рисунке 4, если инструкция HLL hi соответствует последовательности ассемблерных инструкций a1 … a3, установка точки останова на h требует выполнения остановки непосредственно перед a1. Последующий шаг должен выполнить a1 до a3 и остановиться непосредственно перед инструкцией a4.

Эти требования требуют возможности сопоставления "вперед" от местоположений и инструкций исходного кода высокого уровня к последовательностям инструкций любой низкоуровневой формы, подлежащей выполнению или интерпретации. Обычно компилятор связывает формы инструкций HLL с инструкциями низкого уровня по мере генерации последовательностей кода и сохраняет эту информацию в файле или секции объектного модуля.

В следующем разделе мы покажем, что предоставление полезных отчетов об исключениях ставит перед нами задачи, выходящие за рамки интерактивной отладки, особенно когда присутствуют несколько ускорителей в параллельной архитектуре.

IV. ПРИМЕР ОТ НИЗКОУРОВНЕВЫХ ФОРМ ПРОГРАММЫ К ВЫСОКИМ: ОТЧЕТЫ ОБ ИСКЛЮЧЕНИЯХ

Обычно отчет об исключениях времени выполнения включает работу в обратном направлении от низкоуровневых форм программы к высоким. В параллельной, гетерогенной архитектуре существуют дополнительные задачи, к которым относятся:
- Если множество мелкозернистых потоков выполняется параллельно, может быть трудно связать ошибку с конкретным контекстом или ошибочным элементом данных.
- Исключение может возникнуть на специализированном процессоре или ускорителе, который по сути выполняет собственную внутреннюю программу с данными пользовательской программы.
- Исключение вызвано низкоуровневой формой программы, удаленной от формы исходного кода пользователя.

Эти первые две проблемы смягчаются как нашей параллельной программной архитектурой, так и областью применения.

Мы используем крупнозернистую параллельность, при которой один поток обрабатывает данный пакет в режиме Single Program Multiple Data (SPMD). Следовательно, идентичность потока постоянна в течение итерации пользовательской программы на данном пакете. Однако в этой области применения идентичность отказавшего потока (или контекста) обычно менее важна, чем атрибуты текущего пакета в момент сбоя. Эта информация легко доступна, как объяснено ниже.

Мы используем копии интерпретатора, работающие параллельно на микроэнжинах (Рисунок 1), при этом каждый интерпретатор действует как дирижер оркестра, вызывая по мере необходимости услуги специализированных сопроцессоров (ускорителей). Интерпретатор делает такой вызов для реализации семантики индивидуального байт-кода. Таким образом, независимо от сложности внутренней программы сопроцессора, ускоритель может сообщить об исключении вызывающему интерпретатору (Рисунок 5), который может сообщить об исключении пользователям в терминах текущего пакета и байт-кода, потребовавшего услуги сопроцессора.

Таким образом, крупнозернистая модель SPMD избегает проблем, вызванных использованием разнородных, низкоуровневых потоков, и природа нашей архитектуры байт-кодов ISA (которая представляет операции ускорителя как сложные, индивидуальные байт-коды) позволяет нам сопоставлять исключения ускорителя с одним байт-кодом времени выполнения.

Это оставляет нас с третьей проблемой и основным практическим интересом статьи. Как нам сопоставить инструкцию времени выполнения в бинарной форме с исходным кодом пользователя, когда мы прошли через три или более преобразования формы программы? Нам нужно сделать три обратных сопоставления.

- От упакованного байт-кода, вызвавшего исключение, p в P к его неупакованному байт-коду родителю, uj в U
- От неупакованного байт-кода родителя, uj, к его родительской инструкции на языке ассемблера, ak в A.
- От инструкции языка ассемблера, ak к ее родительской инструкции на высокоуровневом языке packetC, hm в H.

Для обработки этих обратных сопоставлений нам нужны компоненты на различных этапах цепочки инструментов - и новый компонент для выполнения соответствующих ролей. Следующий раздел описывает наш подход в терминах этих компонентов и их ролей.


- ускорители
- реализация
- принудительный
- сопоставить
- связанный
- получить
- промежуточный
- поддерживать
- остановка
- требовать
- разнородный
- подвергнуться

